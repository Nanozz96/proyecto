# -*- coding: utf-8 -*-
"""Al parecer es el bueno

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mvFSXUZfIfd2Y0OWRXtmDrylz4h3mC18
"""

!pip install streamlit

import streamlit as st

# Mostrar el código
with st.container():
    proyecto="""

# Datos
revenues = 20
net_profit_margin = 0.20
fixed_capital_investment = 2
depreciation = 3
working_capital_investment_rate = 0.075
tax_rate = 0.40
shares_outstanding = 1
long_term_debt = 32
interest_rate = 0.125
high_growth_rate = 0.10
stable_growth_rate = 0.05
terminal_wacc = 0.15
horizon = 5

# Calcular ingreso neto
net_income = revenues * net_profit_margin

# Calcular interés
interest = (long_term_debt * interest_rate) * (1 - tax_rate)

# Calcular inversión de capital de trabajo
working_capital_investment = revenues * working_capital_investment_rate

# Calcular FCFF para cada año
fcffs = []
for i in range(horizon):
    fcff = net_income + depreciation + interest - working_capital_investment - fixed_capital_investment
    fcffs.append(fcff)
    net_income *= (1 + high_growth_rate)
    interest *= (1 + high_growth_rate)
    depreciation *= (1 + high_growth_rate)
    working_capital_investment *= (1 + high_growth_rate)
    fixed_capital_investment *= (1 + high_growth_rate)

# Calcular valor FCF terminal
terminal_net_income = net_income * (1 + stable_growth_rate)
terminal_interest = interest * (1 + stable_growth_rate)
terminal_depreciation = depreciation * (1 + stable_growth_rate)
terminal_working_capital_investment = working_capital_investment * (1 + stable_growth_rate)
terminal_fixed_capital_investment = terminal_depreciation
terminal_fcf = terminal_net_income + terminal_depreciation + terminal_interest - terminal_working_capital_investment - terminal_fixed_capital_investment

# Calcular valor presente de los FCFF y el valor terminal
pv_fcffs = []
for i in range(horizon):
    pv_fcf = fcffs[i] / ((1 + terminal_wacc) ** (i+1))
    pv_fcffs.append(pv_fcf)

pv_terminal_fcf = (terminal_fcf / (terminal_wacc - stable_growth_rate))/((1+terminal_wacc)**horizon)

# Calcular el valor de la empresa y del patrimonio
value_of_firm = sum(pv_fcffs) + pv_terminal_fcf
value_of_equity = value_of_firm - long_term_debt
value_per_share = value_of_equity / shares_outstanding

# Imprimir resultados
print("Valor de la empresa:", value_of_firm)
print("Valor del patrimonio:", value_of_equity)
print("Valor por acción:", value_per_share)


import numpy as np
import pandas as pd


# Simulacion 1 
# Definimos la media y la desviación estándar
media = 0.20
desviacion_estandar = 0.05

# Definimos el tope mínimo
minimo = 0.075

# Definimos el número de iteraciones
num_iteraciones = 1000

# Generamos los valores aleatorios de la distribución normal y aplicamos el tope mínimo
valores = np.maximum(np.random.normal(media, desviacion_estandar, num_iteraciones), minimo)

# Creamos el DataFrame con los resultados
npm = pd.DataFrame({'Net Profit Margin': valores})

# Imprimimos los resultados estadísticos del DataFrame
print(npm)

# Simulacion 2 
# Definimos la media y la desviación estándar
media = 0.075
desviacion_estandar = 0.025

# Definimos el número de iteraciones
num_iteraciones = 1000

# Generamos los valores aleatorios de la distribución normal y aplicamos el tope mínimo
valores = np.random.normal(media, desviacion_estandar, num_iteraciones)

# Creamos el DataFrame con los resultados
wci = pd.DataFrame({'Working Capital Investment': valores})

# Imprimimos los resultados estadísticos del DataFrame
print(wci)

# Simulacion 3
# Definimos la media y la desviación estándar
media = 0.075
desviacion_estandar = 0.025

# Definimos el número de iteraciones
num_iteraciones = 1000

# Generamos los valores aleatorios de la distribución normal y aplicamos el tope mínimo
valores = np.random.normal(media, desviacion_estandar, num_iteraciones)

# Creamos el DataFrame con los resultados
growth = pd.DataFrame({'Growth': valores})

# Imprimimos los resultados estadísticos del DataFrame
print(growth)

# Concatenacion de los DataFrames
simulaciones = pd.concat([npm, wci, growth], axis=1)
print(simulaciones)

# Lista para almacenar los resultados de cada iteración
resultados = []

# Iteramos sobre cada fila del DataFrame simulaciones
for index, row in simulaciones.iterrows():

    # Datos simulados
    net_profit_margin = row['Net Profit Margin']
    working_capital_investment_rate = row['Working Capital Investment']
    high_growth_rate = row['Growth']

    # Calcular ingreso neto
    net_income = revenues * net_profit_margin

    # Calcular interés
    interest = (long_term_debt * interest_rate) * (1 - tax_rate)

    # Calcular inversión de capital de trabajo
    working_capital_investment = revenues * working_capital_investment_rate

    # Calcular FCFF para cada año
    fcffs = []
    for i in range(horizon):
        fcff = net_income + depreciation + interest - working_capital_investment - fixed_capital_investment
        fcffs.append(fcff)
        net_income *= (1 + high_growth_rate)
        interest *= (1 + high_growth_rate)
        depreciation *= (1 + high_growth_rate)
        working_capital_investment *= (1 + high_growth_rate)
        fixed_capital_investment *= (1 + high_growth_rate)

    # Calcular valor FCF terminal
    terminal_net_income = net_income * (1 + stable_growth_rate)
    terminal_interest = interest * (1 + stable_growth_rate)
    terminal_depreciation = depreciation * (1 + stable_growth_rate)
    terminal_working_capital_investment = working_capital_investment * (1 + stable_growth_rate)
    terminal_fixed_capital_investment = terminal_depreciation
    terminal_fcf = terminal_net_income + terminal_depreciation + terminal_interest - terminal_working_capital_investment - terminal_fixed_capital_investment

    # Calcular valor presente de los FCFF y el valor terminal
    pv_fcffs = []
    for i in range(horizon):
        pv_fcf = fcffs[i] / ((1 + terminal_wacc) ** (i+1))
        pv_fcffs.append(pv_fcf)

    pv_terminal_fcf = (terminal_fcf / (terminal_wacc - stable_growth_rate))/((1+terminal_wacc)**horizon)

    # Calcular el valor de la empresa y del patrimonio
    value_of_firm = sum(pv_fcffs) + pv_terminal_fcf
    value_of_equity = value_of_firm - long_term_debt
    value_per_share = value_of_equity / shares_outstanding

    # Almacenar los resultados de cada iteración en la lista
    resultados.append([value_of_firm, value_of_equity, value_per_share])

# Crear el DataFrame con los resultados
resultados_df = pd.DataFrame(resultados, columns=['Value of Firm', 'Value of Equity', 'Value per Share'])
print(resultados_df)

resultados_completos = pd.concat([resultados_df, simulaciones], axis=1)
print(resultados_completos)

import matplotlib.pyplot as plt

plt.scatter(resultados_df['Value of Firm'], resultados_df['Value of Equity'])
plt.xlabel('Value of Firm')
plt.ylabel('Value of Equity')
plt.title('Simulation Results')
plt.show()
"""

st.code (proyecto, language='python')